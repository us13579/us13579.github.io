---
layout: single
title:  "ğŸ”‘SWEA_SW_5656"
categories: 
    - SWEA
tags: 
    - [2022-04, CodingTest, SWEA, SW, ğŸ”‘]
sidebar:
    nav: "docs"
---

# ğŸ“ <b><a style="color:#00adb5" href="https://swexpertacademy.com/main/code/problem/problemDetail.do?contestProbId=AWXRQm6qfL0DFAUo" target=_blank>[SW_5656] ë²½ëŒ ê¹¨ê¸°</a></b>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Solution {
	static StringTokenizer st;
	static int N, W, H, min;
	// ì˜¤ë¥¸ìª½, ì™¼ìª½, ì•„ë˜, ìœ„
	static int[] dr = { 1, -1, 0, 0 };
	static int[] dc = { 0, 0, 1, -1 };

	static class Point {
		int r, c, cnt;

		public Point(int r, int c, int cnt) {
			super();
			this.r = r;
			this.c = c;
			this.cnt = cnt;
		}
	}

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringBuilder sb = new StringBuilder();

		int t = Integer.parseInt(br.readLine());

		for (int tc = 1; tc <= t; tc++) {
			sb.append("#").append(tc).append(" ");
			st = new StringTokenizer(br.readLine(), " ");

			// êµ¬ìŠ¬ ë†“ëŠ” íšŸìˆ˜
			N = Integer.parseInt(st.nextToken());

			// ê°€ë¡œ
			W = Integer.parseInt(st.nextToken());

			// ì„¸ë¡œ
			H = Integer.parseInt(st.nextToken());

			int[][] map = new int[H][W];

			for (int i = 0; i < H; i++) {
				st = new StringTokenizer(br.readLine(), " ");
				for (int j = 0; j < W; j++) {
					map[i][j] = Integer.parseInt(st.nextToken());
				}
			}

			min = Integer.MAX_VALUE;
			go(0, map);
			sb.append(min).append("\n");

		}
		System.out.println(sb);
	}

	// ì¤‘ë³µìˆœì—´ ì´ìš©í•˜ì—¬ êµ¬ìŠ¬ ë˜ì§€ê¸°
	// ë²½ëŒì´ ë‹¤ ë¶€ì„œì¡Œìœ¼ë©´ true, ì•„ë‹ˆë©´ false
	static boolean go(int count, int[][] map) {
		// ì¤‘ë³µìˆœì—´ êµ¬ì¡°

		int result = getRemain(map);

		// ëª¨ë“  ë²½ëŒì´ ë‹¤ ë¶€ì„œì¡Œë‹¤ë©´
		if (result == 0) {
			min = 0;
			return true;
		}

		// ëª¨ë“  êµ¬ìŠ¬ì„ ë˜ì¡Œë‹¤ë©´
		if (count == N) {
			min = Math.min(min, result);
			return false;
		}

		int[][] newMap = new int[H][W];

		// 0ì—´ë¶€í„° W-1ì—´ê¹Œì§€ êµ¬ìŠ¬ ë˜ì ¸ë³´ê¸°
		for (int c = 0; c < W; c++) {

			// êµ¬ìŠ¬ì— ë§ëŠ” ë²½ëŒ ì°¾ê¸°
			int r = 0;
			// ë¹ˆê³µê°„ì´ë©´ ê³„ì† ì•„ë˜ë¡œ
			while (r < H && map[r][c] == 0)
				++r;

			// í–‰ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ ëë‚¬ë‹¤ë©´ í•´ë‹¹ ì—´ì€ ë²½ëŒì´ ì—†ìŒ
			if (r == H)
				continue;

			// ë°°ì—´ì˜ ìƒíƒœë¥¼ ë°±ì—…
			copy(map, newMap);

			// í˜„ì¬ ë²½ëŒ ê¸°ì¤€ìœ¼ë¡œ ì£¼ë³€ì˜ ê°€ëŠ¥í•œ ëª¨ë“  ë²½ëŒ í•¨ê»˜ ì—°ì‡„ ì²˜ë¦¬
			boom(newMap, r, c);

			// ë¶€ì„œì§„ ë²½ëŒ ì •ë¦¬
			down(newMap);

			// ë‹¤ìŒ ë°°ì—´ë¡œ ì¶œë°œ
			// ì´ë¯¸ ëë‚¬ë‹¤ë©´ ë’¤ì— ëŒ í•„ìš”ê°€ ì—†ë‹¤.
			if (go(count + 1, newMap)) {
				return true;
			}
		}
		// ìœ„ì— êµ¬ë¬¸ì—ì„œ true ê°€ ì•ˆë‚˜ì˜¤ë©´ ë‹¤ ë¶€ì„œì§€ì§€ ì•Šì•˜ë‹¤ëŠ” ëœ»
		return false;

	}

	// y,x ìœ„ì¹˜ì—ì„œ ì£¼ë³€ì˜ ê°€ëŠ¥í•œ ëª¨ë“  ë²½ëŒë„ í•¨ê»˜ë¶€ìˆ˜ëŠ” ì²˜ë¦¬
	// BFS
	static void boom(int[][] map, int r, int c) {
		// BFS
		Queue<Point> q = new LinkedList<Point>();
		// ë²½ëŒ í¬ê¸°ê°€ 2ì´ìƒì´ë©´ queueì— ì‚½ì…
		if (map[r][c] > 1) {
			q.offer(new Point(r, c, map[r][c]));
		}
		map[r][c] = 0; // ìì‹ ì€ ì œê±° ì²˜ë¦¬ -> visit ì²˜ë¦¬ë‘ ê°™ì€ ì—­í• ì„ í•œë‹¤

		while (!q.isEmpty()) {
			Point p = q.poll();

			for (int i = 0; i < 4; i++) {
				int nr = p.r, nc = p.c;

				// ë²½ëŒì˜ í¬ê¸° - 1ë§Œí¼ ë°˜ë³µ, ê³„ì† ì˜†ìœ¼ë¡œ ê°€ëŠ”ê±°ë‹¤
				for (int j = 1; j < p.cnt; j++) {
					nr += dr[i];
					nc += dc[i];
					if (nr >= 0 && nr < H && nc >= 0 && nc < W) {
						if (map[nr][nc] > 1) {	// ì£¼ë³€ì— ì˜í–¥ì„ ì£¼ëŠ” ë²½ëŒì´ë©´
							q.offer(new Point(nr, nc, map[nr][nc]));
						}
						map[nr][nc] = 0;	// ë¹ˆê³µê°„ì´ë©´ 0, ë²½ëŒì´ë©´ ì œê±°ì²˜ë¦¬
					}
				}
			}
		}
	}

	// ë¶€ì„œì§„ ë²½ëŒ ì •ë¦¬, ë°‘ìœ¼ë¡œ ë³´ë‚´ê¸° !! ( ê³µì¤‘ì— ë– ìˆëŠ” ê²ƒë“¤ )
	static ArrayList<Integer> list = new ArrayList<Integer>();

	static void down(int[][] map) {
		// ì—´ ê³ ì •
		for (int c = 0; c < W; c++) {
			// ë§¨ë°‘ì¹¸ë¶€í„° ì‹œì‘
			int r = H - 1;
			while (r > 0) {
				if(map[r][c] == 0) {
					int nr = r-1;
					while(nr>0 && map[nr][c] == 0) nr--;
					
					map[r][c] = map[nr][c];
					map[nr][c] = 0;
				}
				r--;
			}
		}
	}

	// ë‚¨ì€ ë²½ëŒ ìˆ˜ êµ¬í•˜ê¸°
	static int getRemain(int[][] map) {
		int count = 0;
		for (int r = 0; r < H; r++) {
			for (int c = 0; c < W; c++) {
				if (map[r][c] > 0) {
					count++;
				}
			}
		}
		return count;
	}

	// ë°°ì—´ ë³µì‚¬
	static void copy(int[][] map, int[][] newMap) {
		for (int r = 0; r < H; r++) {
			for (int c = 0; c < W; c++) {
				newMap[r][c] = map[r][c];
			}
		}
	}
}
```


## ğŸ¤” <b><a style="color:#00adb5">ë‚˜ì˜ ìƒê°</a></b>
ì‹œë®¬ë ˆì´ì…˜ ë¬¸ì œì´ë‹¤.<br>
êµ¬ìŠ¬ì„ ë–¨ì–´ëœ¨ë ¤ ë²½ëŒì„ ê¹¨ëŠ”ë° ë²½ëŒ ì•ˆì— ìˆëŠ” ìˆ˜ë§Œí¼ì˜ ë²”ìœ„ë¡œ ìƒí•˜ì¢Œìš° ë” ê¹¨ì§„ë‹¤ê³  í•œë‹¤.<br>
ê·¸ëŸ¬ë©´ êµ¬ìŠ¬ì„ ë–¨ì–´ëœ¨ë¦´ ìœ„ì¹˜ , ë²½ëŒ ìˆ˜ ë²”ìœ„ë§Œí¼ í­íŒŒ, í­íŒŒëœ ë¹ˆì¹¸ ì±„ìš°ê¸°, ë‚¨ì€ ë²½ëŒ ìˆ˜ êµ¬í•˜ê¸° ë¥¼ êµ¬í˜„í•˜ë©´ ëœë‹¤.<br>
êµ¬ìŠ¬ì„ ë–¨ì–´ëœ¨ë¦´ ìœ„ì¹˜ëŠ” ì¤‘ë³µìˆœì—´ì„ ì´ìš©í•˜ì—¬ êµ¬í˜„í•˜ê³  <br>
ë²½ëŒ ìˆ˜ ë§Œí¼ í­íŒŒí•˜ëŠ” ê³¼ì •ì€ BFSë¥¼ í™œìš©í•˜ì—¬ êµ¬í˜„í•´ì•¼í•œë‹¤. ì™œëƒí•˜ë©´ êµ¬ìŠ¬ì„ ê°™ì€ ìœ„ì¹˜ì— ê³„ì† ë†“ì„ ìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì´ë‹¤.<br>
ê·¸ë¦¬ê³  í­íŒŒëœ ë’¤ 0ì´ ëœ ë²½ëŒë“¤ì€ ì—†ì–´ì§€ë¯€ë¡œ ê·¸ ë¹ˆì¹¸ì„ ì±„ìš°ê¸° ìœ„í•´ í–‰ì˜ ë§¨ ë°‘ë¶€í„° ìœ„ë¡œ ì˜¬ë¼ì˜¤ë©´ì„œ ì²´í¬ë¥¼ í•˜ê³  ìˆ˜ë¥¼ ë°”ê¿”ì¤€ë‹¤.<br>
ì´ ê³¼ì •ì„ ë°˜ë³µí•˜ì—¬ ìµœëŒ€í•œ ë§ì€ ë²½ëŒì„ ì œê±°í–ˆì„ ë•Œ ë‚¨ì€ ë²½ëŒ ìˆ˜ë¥¼ êµ¬í•˜ë©´ ëœë‹¤.