---
layout: single
title: "BOJ_G3_17822"
categories:
  - BOJ
tags:
  - [2022-07, CodingTest, BOJ, G3]
sidebar:
  nav: "docs"
---

# ğŸ“ <b><a style="color:#00adb5" href="https://www.acmicpc.net/problem/17822" target=_blank>[G3_17822] ì›íŒ ëŒë¦¬ê¸°</a></b>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {

	static class Node {
		int x;
		int y;

		public Node(int x, int y) {
			super();
			this.x = x;
			this.y = y;
		}
	}

	static int[][] map;
	static int N, M, T;
	static int[] dx = { 0, 0, 1, -1 };
	static int[] dy = { 1, -1, 0, 0 };
	static boolean[][] v;
	static Queue<Node> q;
	static ArrayList<Node> list;

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");

		// **** input start ****
		N = Integer.parseInt(st.nextToken());
		M = Integer.parseInt(st.nextToken());
		T = Integer.parseInt(st.nextToken());

		// ì›ë°˜ ì¢Œí‘œë“¤
		map = new int[N + 1][M + 1];

		// ì¢Œí‘œ ì…ë ¥
		for (int i = 1; i < N + 1; i++) {
			st = new StringTokenizer(br.readLine(), " ");
			for (int j = 1; j < M + 1; j++) {
				map[i][j] = Integer.parseInt(st.nextToken());
			}
		}

		// íšŒì „
		for (int i = 0; i < T; i++) {
			st = new StringTokenizer(br.readLine(), " ");

			int x = Integer.parseInt(st.nextToken());
			int d = Integer.parseInt(st.nextToken());
			int k = Integer.parseInt(st.nextToken());

			// íšŒì „ ì‹œí‚¤ê¸°
			rotate(x, d, k);

			// ì¸ì ‘í•œ ê²ƒì´ ìˆëŠ”ì§€ ì²´í¬
			boolean check = find();
			// ì¸ì ‘í•œ ê²ƒì´ ì—†ë‹¤ë©´
			if (!check) {
				// í‰ê· ê³„ì‚°
				calAvg();
			}
		}

		// ì¶œë ¥
		int sum = 0;
		for (int i = 1; i < N + 1; i++) {
			for (int j = 1; j < M + 1; j++) {
					sum += map[i][j];
			}
		}

		System.out.println(sum);

	} // main end

	static void calAvg() {
		double sum = 0;
		double cnt = 0;

		// í‰ê·  êµ¬í•˜ê¸°
		for (int i = 1; i < N + 1; i++) {
			for (int j = 1; j < M + 1; j++) {
				// ê°’ì´ ìˆìœ¼ë©´
				if (map[i][j] > 0) {
					sum += map[i][j];
					cnt++;
				}
			}
		}

		// ë§Œì•½ ê°’ì´ ì—†ë‹¤ë©´ í†µê³¼
		if (cnt == 0)
			return;

		double avg = sum / cnt;

		// í‰ê· ê°’ì„ ê°€ì§€ê³  ë”í•˜ê¸°, ë¹¼ê¸° ì‹¤í–‰
		for (int i = 1; i < N + 1; i++) {
			for (int j = 1; j < M + 1; j++) {
				// ì•„ë¬´ê²ƒë„ ì—†ìœ¼ë©´ í†µê³¼
				if (map[i][j] == 0)
					continue;
				// í‰ê· ë³´ë‹¤ í¬ë©´ 1 ë¹¼ê¸°
				if (map[i][j] > avg)
					map[i][j] -= 1;
				// í‰ê· ë³´ë‹¤ ì‘ìœ¼ë©´ 1 ë”í•˜ê¸°
				else if (map[i][j] < avg)
					map[i][j] += 1;
			}
		}
	}

	// ê°™ì€ ë²ˆí˜¸ì¸ì§€ ì°¾ê¸°
	static boolean find() {
		// ì¸ì ‘í•œ ê²ƒ ì¤‘ ê°™ì€ ê°’ì´ ìˆëŠ”ì§€ ì²´í¬ -> ìˆìœ¼ë©´ true, ì—†ìœ¼ë©´ false
		boolean flag = false;
		// ì¸ì ‘í•œì§€ ì²´í¬ ë°°ì—´
		v = new boolean[N + 1][M + 1];
		// í ìƒì„±
		q = new LinkedList<Node>();
		// ë¦¬ìŠ¤íŠ¸ ìƒì„± - ì¸ì ‘í•œ ìˆ˜ë“¤ì´ ëª‡ê°œ ìˆëŠ”ì§€ ì²´í¬
		list = new ArrayList<Node>();

		// ëª¨ë“  ì¢Œí‘œ BFS íƒìƒ‰
		for (int i = 1; i < N + 1; i++) {
			for (int j = 1; j < M + 1; j++) {
				// ì´ë¯¸ ë°©ë¬¸í–ˆê±°ë‚˜ ì œê±°í–ˆìœ¼ë©´ í†µê³¼
				if (v[i][j] || map[i][j] == 0)
					continue;
				Node cur = new Node(j, i);
				// í, ë¦¬ìŠ¤íŠ¸ ì¶”ê°€
				q.add(cur);
				list.add(cur);

				// BFS
				bfs(map[i][j]);

				// listì— 2ê°œ ì´ìƒ ìˆë‹¤ë©´ -> ì‚­ì œí•´ì£¼ê¸°
				if (list.size() > 1) {
					// ë³€ê²½ëë‹¤ëŠ” ì˜ë¯¸
					flag = true;
					// ì›íŒì—ì„œ ìˆ«ì ì œê±°
					for (Node node : list) {
						map[node.y][node.x] = 0;
					}
				}
				// ë¦¬ìŠ¤íŠ¸ ì´ˆê¸°í™”
				list.clear();
			}
		}
		// ì¸ì ‘í•œ ê²ƒì´ ìˆëŠ”ì§€ ìœ ë¬´ ë°˜í™˜
		return flag;
	}

	// 4ë°©í–¥ íƒìƒ‰
	static void bfs(int point) {
		while (!q.isEmpty()) {
			Node cur = q.poll();

			int nx, ny;
			for (int i = 0; i < 4; i++) {
				nx = cur.x + dx[i];
				ny = cur.y + dy[i];


				// X ëŠ” ë‹¤ ì—°ê²°ë˜ì–´ ìˆë‹¤.
				if (nx < 1)
					nx = M;
				else if (nx > M)
					nx = 1;

				// Y - ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ê±°ë‚˜ ë°©ë¬¸í–ˆë˜ ê³³ì´ë©´ í†µê³¼
				if (ny < 1 || ny > N || v[ny][nx])
					continue;

				// ë§Œì•½ ì¸ì ‘í•œ ì¢Œí‘œì˜ ìˆ«ìê°€ ê°™ì€ ê²½ìš°
				if (map[ny][nx] == point) {
					// ë°©ë¬¸ì²˜ë¦¬
					v[ny][nx] = true;
					Node node = new Node(nx, ny);
					// queue ì— ì‚½ì…
					q.add(node);
					// ë¦¬ìŠ¤íŠ¸ì— ì‚½ì…
					list.add(node);
				}
			}
		}
	}

	// íšŒì „ì‹œí‚¤ê¸°
	static void rotate(int x, int d, int k) {
		// kë²ˆ íšŒì „ì‹œí‚¤ê¸°
		while (k > 0) {
			for (int i = 1; i < N + 1; i++) {
				// xì˜ ë°°ìˆ˜ì´ë©´ íšŒì „
				if (i % x == 0) {
					// ì‹œê³„ë°©í–¥ìœ¼ë¡œ
					if (d == 0) {
						// ë§ˆì§€ë§‰ ê°’
						int last = map[i][M];
						for (int j = M; j > 0; j--) {
							map[i][j] = map[i][j - 1];
						}
						map[i][1] = last;
					}
					// ë°˜ì‹œê³„ë°©í–¥ìœ¼ë¡œ
					else {
						// ì²˜ìŒ ê°’
						int first = map[i][1];
						for (int j = 1; j < M; j++) {
							map[i][j] = map[i][j + 1];
						}
						map[i][M] = first;
					}
				}
			}
			k--;
		}
	}
} // class end
```

## ğŸ¤” <b><a style="color:#00adb5">ë‚˜ì˜ ìƒê°</a></b>

í™•ì‹¤íˆ ë‚œì´ë„ê°€ ì˜¬ë¼ê°€ë‹ˆ ë¬¸ì œì— ì¡°ê±´ë„ ë§ê³  ë¬¸ì œ ìì²´ë¥¼ ì´í•´í•˜ê¸°ë„ ê·¸ë ‡ê²Œ ì‰½ì§€ëŠ” ì•Šì•˜ë‹¤.<br>
ì‚¬ì‹¤ ì‹œê°„ë‚´ì—ëŠ” í’€ì§€ ëª»í–ˆëŠ”ë° ê¸°ì¡´ ë¬¸ì œì— ëŒ€í•œ ì´í•´ë„ í‹€ë ¸ì—ˆë‹¤. í‰ê· ê³„ì‚°ì„ ë§¨ ë§ˆì§€ë§‰ì— í•œ ë²ˆë§Œ í•´ì£¼ëŠ” ì¤„ ì•Œì•˜ëŠ”ë° .. ã… <br>
ê·¸ë˜ì„œ ë‚´ê°€ í‘¼ ë°©ë²•ì€ ë‹¤ìŒê³¼ ê°™ë‹¤.<br>
í° í‹€ë¡œëŠ” rotate ë©”ì„œë“œë¡œ ì¢Œí‘œ ì´ë™, find ë©”ì„œë“œë¡œ ëª¨ë“  ì¢Œí‘œë¥¼ bfs íƒìƒ‰í•˜ë©´ì„œ ê°’ì´ ë°”ë€Œì—ˆëŠ”ì§€ ì•ˆë°”ë€Œì—ˆëŠ”ì§€ ë°˜í™˜, calAvg ë©”ì„œë“œë¥¼ í†µí•´ ê°’ì´ ì•ˆ ë°”ë€Œì—ˆë‹¤ë©´ í‰ê·  ê³„ì‚°ì„ í•´ì¤€ë‹¤.<br>
ì‚¬ì‹¤ bfsë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ê´œì°®ì§€ë§Œ ì‹œê°„ì ì¸ ë¶€ë¶„ì—ì„œ í™•ì‹¤íˆ ë‹¨ì¶•ì‹œì¼œì¤„ ìˆ˜ ìˆì„ ê²ƒ ê°™ì•„ ì‚¬ìš©í–ˆë‹¤.<br>
ê·¸ë¦¬ê³  queueëŠ” bfs íƒìƒ‰ì„ ìœ„í•´ ì‚¬ìš©, 2ì°¨ì› ë°°ì—´ mapì€ ì „ì²´ ì¢Œí‘œë¥¼ ì €ì¥, listëŠ” ì¸ì ‘í•´ ìˆëŠ” ê°’ë“¤ì„ ì €ì¥í•´ ë‚˜ì¤‘ì— ê°’ì„ ì—†ì• ê±°ë‚˜ ë³€ê²½ë¨ì„ ë‚˜íƒ€ë‚´ëŠ” ê²ƒìœ¼ë¡œ ì‚¬ìš©í•˜ì˜€ë‹¤.<br>
ì „ì²´ ìˆœì„œ ê³¼ì •ì„ ë‚˜íƒ€ë‚´ ë³´ê² ë‹¤.

- ë¨¼ì € ê°’ë“¤ì„ ì…ë ¥ë°›ëŠ”ë‹¤. ( map, x, d, k ë“±)
- ë‹¤ìŒìœ¼ë¡œ x,d,kë¥¼ ì´ìš©í•´ì„œ rotate ì¢Œí‘œë“¤ì„ ì´ë™ì‹œí‚¨ë‹¤. ( ì‹œê³„ë°©í–¥, ë°˜ì‹œê³„ ë°©í–¥ )
  - ì‹œê³„ë°©í–¥ì€ ë§¨ ë’¤ì— ê°’ì„ ë¹¼ë†“ê³  í•œ ì¹¸ì”© ì´ë™ í‚¤ì‹œê³  ë°˜ì‹œê³„ë°©í–¥ì€ ë§¨ ì•ì— ê°’ì„ ë¹¼ë†“ê³  í•œ ì¹¸ì”© ì´ë™ì‹œì¼°ë‹¤.
- ë‹¤ìŒì€ ëª¨ë“  ì¢Œí‘œì—ì„œ bfs íƒìƒ‰ì„ í•´ ì¸ì ‘í•œ ê°’ë“¤ì´ ìˆëŠ”ì§€ ì²´í¬í•´ ì¤€ë‹¤.
- ë§Œì•½ ìˆìœ¼ë©´ ê·¸ ê°’ë“¤ì„ listì— ì €ì¥ì‹œì¼œ listì— ìˆëŠ” ê°’ë“¤ì„ 0ìœ¼ë¡œ ë°”ê¿”ì¤€ë‹¤. ( ì‚­ì œ ë˜ì—ˆë‹¤ëŠ” ì˜ë¯¸ )
- ë‹¤ íƒìƒ‰í•˜ê³  ë‚˜ì„œ flag ( ì¸ì ‘í•œ ê°’ì´ ìˆëŠ”ì§€ ì—†ëŠ”ì§€ í‘œì‹œí•´ì£¼ëŠ” boolean ê°’ ) ê°’ì„ í†µí•´ ë§Œì•½ ê°’ì´ ë³€ê²½ëœê²Œ ì—†ë‹¤ë©´ í‰ê· ê°’ì„ êµ¬í•´ì£¼ê³  í‰ê· ë³´ë‹¤ ì‘ìœ¼ë©´ 1ì„ ë”í•˜ê³  í‰ê· ë³´ë‹¤ í¬ë©´ 1ì„ ë¹¼ì£¼ëŠ” ì‘ì—…ì„ í•œë‹¤.
- ì´ ê³¼ì •ì„ të§Œí¼ ë°˜ë³µí•˜ê³  ë§ˆì§€ë§‰ì— ë‚¨ì€ ê°’ë“¤ì„ ëª¨ë‘ ë”í•´ ë‚˜íƒ€ë‚´ ì¤€ë‹¤.
